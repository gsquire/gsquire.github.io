
<!DOCTYPE html>
<html lang="en-us">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta content="" name="keywords">
<meta content="REST in Rust - Garrett&#39;s Blog" property="og:title">
<title>REST in Rust | Garrett&#39;s Blog</title>
<link rel="stylesheet" href="https://gsquire.github.io/static//css/style.css">
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css" integrity="sha256-Zd1icfZ72UBmsId/mUcagrmN7IN5Qkrvh75ICHIQVTk=" crossorigin="anonymous" />


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://gsquire.github.io/static/"><h1 class="title is-4">Garrett&#39;s Blog</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h2 class="subtitle is-6">June 14, 2016</h2>
    <h1 class="title">REST in Rust</h1>
    
    <div class="content">
      

<h1 id="writing-a-simple-rest-app-in-rust">Writing a simple REST app in Rust</h1>

<p>If you have ever worked with HTTP in Rust, you have probably referred to the
<a href="hyper.rs">hyper</a> crate. Hyper provides a safe abstraction over HTTP and offers both
a client and server type. It is also the foundation for frameworks such as <a href="https://github.com/iron/iron">Iron</a>
and <a href="https://github.com/nickel-org/nickel.rs">Nickel</a>.</p>

<p>One of the coolest things about hyper is that its server can be started with anything that
implements the <a href="http://hyper.rs/hyper/v0.9.8/hyper/server/trait.Handler.html"><code>Handler</code></a> trait.
There is one required method called <code>handle</code> and it denotes how the type which implements it
should respond to an incoming connection.</p>

<p><code>handle</code> has the following function signature:</p>

<pre><code>fn handle&lt;'a, 'k&gt;(&amp;'a self, Request&lt;'a, 'k&gt;, Response&lt;'a, Fresh&gt;)
</code></pre>

<p>As you can see it gives us access to a <code>Request</code> and <code>Response</code> type which are aptly named. If you take a look
at the documentation for these, you will find that they provide the basis to check
for HTTP headers or set the body of an HTTP response.</p>

<h2 id="regexset"><code>RegexSet</code></h2>

<p>The regex crate recently added a type called a <a href="https://doc.rust-lang.org/regex/regex/struct.RegexSet.html"><code>RegexSet</code></a>.
This is a powerful construct in that it can match multiple patterns that you provide in a single
scan. Using this idea, I thought it would be fun to write a router with a <code>RegexSet</code> matching
requests under the hood.</p>

<p>The result of this is <a href="https://github.com/gsquire/reroute">reroute</a>. This crate provides a <code>Router</code>
type that can match patterns you provide and call corresponding functions accordingly. The functions have access
to the <code>Request</code> and <code>Response</code> along with a type that captures matches in the URI.</p>

<h2 id="a-simple-example">A simple example</h2>

<pre><code class="language-rust">extern crate hyper;
extern crate reroute;

use hyper::Server;
use hyper::server::{Request, Response};
use reroute::{Captures, Router};

fn digit_handler(_: Request, res: Response, c: Captures) {
    println!(&quot;captures: {:?}&quot;, c);
    res.send(b&quot;It works for digits!&quot;).unwrap();
}

fn main() {
    let mut router = Router::new();

    // Use raw strings so you don't need to escape patterns.
    router.get(r&quot;/(\d+)&quot;, digit_handler);

    router.finalize().unwrap();

    // You can pass the router to hyper's Server's handle function as it
    // implements the Handle trait.
    Server::http(&quot;127.0.0.1:3000&quot;).unwrap().handle(router).unwrap();
}
</code></pre>

<p>Since <code>Router</code> implements the <code>Handler</code> trait, hyper&rsquo;s <code>Server</code> can use it to respond
to connections. With this in mind, you can write a REST app in a few lines and extend this
functionality to suit your own needs. The <code>Captures</code> type gives you matches in your URI that the regex
engine finds. So in the example above, if I do a GET against the route &ldquo;/123&rdquo;, <code>c</code> will be
<code>Some([&quot;/123&quot;, &quot;123&quot;])</code>. This is a <code>Vector</code> of the matches returned from the <code>RegexSet</code>. You
can use any pattern with grouping that you like and the router will collect them for you. Of course
you don&rsquo;t need to provide groups and can just add routes like &ldquo;/v1/some/endpoint&rdquo; as well.</p>

<p>Reroute surely isn&rsquo;t as complete as Iron but its only goal is to route requests in an app.</p>

<h2 id="questions-or-thoughts">Questions or thoughts?</h2>

<p>Feel free to contact me through the email on my <a href="https://github.com/gsquire">GitHub</a> profile.</p>

    </div>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p></p>
  </div>
</section>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin="anonymous"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/go.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/rust.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/shell.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


